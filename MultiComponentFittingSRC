import numpy as np
import pandas as pd
import lmfit
import os
import pickle
import matplotlib.pyplot as plt
plt.close('all')

import flopy_no_leakage

piez = dict(task_name = 'piez', 
            normalize_time = False,
            normalize_hs = False,
            )

class WavePropagationAquifers:
    
    def __init__(self,
                 task_name = 'wave',
                 task_root = '../../results/No_leakage' ,
                 hk  = 25,
                 ss = 5E-5,               
                 **settings,
                 ):
    
        self.task_name = task_name
        self.task_root = task_root

        self.hk = hk  # horizontal hydraulic conductivity
        self.ss = ss  # storage term
        
        # self.settings = copy.copy(DEF_settings)
        # self.settings.update(**settings)

        self.wave = None
        self.fft = None
    
    def read_wave(self,
                  file_wave = None,
                  cut_input = False,
                  R_fft = False,
                  normalize_time = True,
                  coarsen_time = 0,
                  normalize_hs = True,
                  **kwargs,
                  ):
        
        """ read in complex wave data from file and preprocess
        """
        
        if file_wave == None:
            file_wave = '../../data/{}.txt'.format(self.task_name)
            # file_wave = '../data/{}.csv'.format(self.task_name)
        if not os.path.isfile(file_wave):
            raise ValueError("wave input file is not valid: " + str(file_wave))
        
        tide = np.loadtxt(file_wave)#,delimiter=',')
        if cut_input:
            tide = tide[:int(cut_input),:]

        self.dt = (tide[-1,0]-tide[0,0])/len(tide[:,0])
        
        if normalize_time is False:
            self.wave_time = tide[:,0]
            self.wave = tide[:,1]
        else:
            wave_time = tide[:,0]
            wave = tide[:,1]

            if coarsen_time>0:
                self.wave_time = np.arange(wave_time[0],wave_time[-1]+self.dt,coarsen_time*self.dt)
                self.dt *= coarsen_time
            else:
                self.wave_time = np.arange(wave_time[0],wave_time[-1]+self.dt,self.dt)
            self.wave = np.interp(self.wave_time,wave_time,wave)

        if normalize_hs:
            if normalize_time:
                hs0 = np.mean(self.wave)
            else:
                hs0 = np.average(self.wave[:-1], weights=np.diff(self.wave_time))
            self.wave -= hs0

        return self.wave_time,self.wave
    
    def plot_wave(self,
                  save = False,
                  **kwargs,
                  ):
        
        plt.plot(self.wave_time,self.wave,ls = '-', color='C0',label='input {}'.format(self.task_name))        
        plt.grid(True)
        plt.xlabel("Time $t$")
        plt.ylabel("Water table $h(t)$")
        plt.legend()

        if save:
            plt.savefig('{}.png'.format(self.task_root), dpi=300)
            
    def run_numerical_model(self,
                            dir_sim = None,
                            write_to_file = True,
                            file_results = None,
                            **kwargs,
                            ):

        if self.wave is None:
            raise ValueError('Input wave not give. Read in wave data first.')

        if dir_sim is None:
            dir_sim ='{}/NumModel_{}/'.format(self.task_root, self.task_name) 
        try:
            os.mkdir(dir_sim)
        except:
            pass
        print("Run ModFlow Model \n for boundary condition: {}\n in directory: {} \n".format(self.task_name,dir_sim))

        times_num,x_num,head_tx_num = flopy_no_leakage.model(
            dt=self.dt,
            wave=self.wave,    
            task_name = self.task_name,
            task_root = dir_sim,
            hk = self.hk,
            ss = self.ss,
            ) 
        
        self.times_num = np.array(times_num)
        self.x_num = np.array(x_num)
        self.head_tx_num = np.array(head_tx_num)
        
        if write_to_file:
            self.write_num_to_pickle(file_results = file_results)

        return self.times_num,self.x_num,self.head_tx_num
        # return self.head_tx_num

    def write_num_to_pickle(self,
                            file_results = None,                            
                            **kwargs,
                            ):

        if file_results is None:
             file_results= r'{}/{}_numerical.p'.format(self.task_root,self.task_name)
        else:
            file_results = file_results
            
        # Write data in binary format
        with open(file_results, 'wb') as filehandle:
            # store the data as binary data stream
            pickle.dump([self.wave_time,self.x_num,self.head_tx_num], filehandle)
        print("\nSimulation results saved to binary (pickle) file: \n {}".format(file_results))
    
    def write_piez_to_txt(self,
                          x=1,
                          file_results = None,                            
                          **kwargs,
                          ):

        if file_results is None:
             file_results= r'../../data/piez.txt'

        # Write data in text format
        np.savetxt(file_results, self.piez)
        print("\nSimulation results saved to binary (pickle) file: \n {}".format(file_results))

    def read_num_from_pickle(self,
                             file_results = None,                            
                             **kwargs,
                             ):
        
        if file_results is None:
            file_results= r'{}/{}_numerical.p'.format(self.task_root,self.task_name)
            
        if not os.path.isfile(file_results):
            raise ValueError('File with stored numerical model results not existant at: \n {}'.format(file_results))

        with open(file_results, 'rb') as filehandle:
            data = pickle.load(filehandle)

        x_num = data[1]
        times_num = data[0]
        head_tx_num = data[2]
        # self.x_num = data[0]
        # self.times_num = data[1]
        # self.head_tx_num = data[2].T
        # read the data as binary data stream
        self.data = dict(
            x_num = x_num,
            t_num = times_num,
            h_num = head_tx_num,
            )
        
        return self.data
            

    def decompose_wave_fft(self,
                           amplitude_threshold= 0.0,
                           **kwargs,
                           ):
        #################################################################################
        # Decompose tidal wave
        #################################################################################
        fft = np.fft.fft(self.wave)
        
        nt = len(self.wave_time)
        freqs = np.fft.fftfreq(len(self.wave_time),self.dt)
        
        if (nt % 2) == 0:     # Check if n_obs is even or odd
            middle = nt//2
        else:
            middle = nt//2 + 1
        
        wavelength   = freqs[0:middle] * 2.*np.pi
        phase_shift  = np.arctan2(fft.imag[0:middle],fft.real[0:middle])
        # phase_shift  = np.arctan2(fft.imag[0:middle],fft.real[0:middle]) + np.pi/2
        amplitude    = np.zeros(middle)
        
        for i in range(middle):
            if abs(fft[i])/(nt) > amplitude_threshold:
                if i == 0:
                    coeff = 2
                else:
                    coeff = 1
                amplitude[i] = 1/(nt*coeff/2.) * np.sqrt(fft.real[i]**2 + fft.imag[i]**2)
    
        self.fft = dict(
            wavelength = wavelength,
            phase_shift = phase_shift,
            amplitude = amplitude,
            )
 
        return self.fft
    
    
    def reconstruct_wave_fft(self,
                             **kwargs,
                             ):
    
        #################################################################################
        # Reconstruct tidal wave and compare with the original wave
        #################################################################################

        if self.fft is None: 
            self.decompose_wave_fft(**kwargs)
       
        nt = len(self.wave_time)
        n_fft = len(self.fft['amplitude'])
        
        amp = np.tile(self.fft['amplitude'],(nt,1))
        wl = np.tile(self.fft['wavelength'],(nt,1))
        ps = np.tile(self.fft['phase_shift'],(nt,1))
        self.t_wave_reconstr = np.linspace(-0.1*max(self.wave_time),max(self.wave_time)+0.1*max(self.wave_time),nt)
        wt = np.tile(self.t_wave_reconstr,(n_fft,1)).T
        
        self.wave_reconst = np.sum(amp*np.cos(wl*wt + ps),axis = 1)
        
        return self.wave_reconst, self.t_wave_reconstr

    def select_times(self,
                     nt = 15,
                     wout_version = True,
                     ):


        ### Wout's way (but error prone --> replace by new way after result checking)
        if wout_version:
            index = np.ones(nt)        
            for i in range(nt):
                index[i] = (i) * int(len(self.wave_time)/nt)
            self.t_indices = np.array(index,dtype = int)        

        else:
            ### improved way
            self.t_indices = np.linspace(0,len(self.wave_time)-1,nt,endpoint=True,dtype = int)
            # self.t_indices = np.linspace(0,len(self.wave_time),nt,endpoint=False,dtype = int)

        self.t_select = self.wave_time[self.t_indices]
        self.t_rel  = self.t_select/self.wave_time[-1]
 
        return self.t_indices,self.t_select,self.t_rel

    def run_analytical_model(self,
                                t_ana = 100,
                                x_ana = np.linspace(0,3000,20),   
                                write_to_file = True,
                                as_loop = False,
                                **kwargs,
                                ):

        if isinstance(t_ana,int):
            ### select t_ana time points within the wave_time (at equal distance)
            self.select_times(nt = t_ana)
            t_ana= self.t_select
        elif isinstance(t_ana,list):
            t_ana = np.array(t_ana)
        elif isinstance(t_ana,np.ndarray):
            pass
        else:
            raise ValueError('Input of time series not correct: integer, list or array')

        #################################################################################
        ### Check availability of wave decomposition components of input wave       
        #################################################################################
        if self.fft is None: 
            self.decompose_wave_fft(**kwargs)
        
        #################################################################################
        ### Set up analytical solution
        #################################################################################      
        A = self.fft['amplitude']
        w = self.fft['wavelength']
        phi = self.fft['phase_shift']
        
        x = np.array([x_ana])
        x = np.array([x]).transpose(0,2,1)
        
        t = np.array([t_ana])
        t = np.array([t]).transpose(2,0,1)
        
        A = np.array([A])
        A = np.array([A])
        
        w = np.array([w])
        w = np.array([w])
        
        phi = np.array([phi])
        phi = np.array([phi])
        
        h_xt = A * np.exp( -x*np.sqrt(w * self.ss/(2*self.hk)) ) * np.cos( w*t + phi -x*np.sqrt(w * self.ss/(2*self.hk)) )
        
        self.x_ana = x_ana
        self.times_ana = t_ana
        self.head_tx_ana = h_xt.sum(axis=2)
        
        if write_to_file:
            self.write_ana_to_pickle()

        return self.times_ana,self.x_ana,self.head_tx_ana
    
    def get_piezometric_data(self,
                             x = 400,
                             write_to_file = True,
                             **kwargs,
                             ):
        #if self.data is None: 
        #    self.read_num_from_pickle(**kwargs)
        
        self.read_num_from_pickle(**kwargs)
            
        x_num = self.data["x_num"]
        t_num = self.data["t_num"]
        h_num = self.data["h_num"]
        
        index = (np.abs(x_num - x)).argmin()
        
        self.x_piez = x
        self.t_piez = t_num
        self.h_piez = h_num[:,index] #+ noise
        data = np.transpose(np.array([self.t_piez, self.h_piez]))
        
        self.piez = pd.DataFrame(data=data)
        
        if write_to_file:
            self.write_piez_to_txt(x=x)
        
        return self.x_piez, self.t_piez, self.h_piez, self.piez
    
    def extract_wave_component(self,
                               index=None,
                               threshold=None,
                               max_period = None,
                               **kwargs):
        if self.fft is None:
            self.decompose_wave_fft(**kwargs)
        
        data = np.transpose(np.array([self.fft['wavelength'],self.fft['amplitude'],self.fft['phase_shift']]))
        fft = pd.DataFrame(data, columns=['wavelength','amplitude','phase_shift'])
        
        fft_period = 2*np.pi / fft.wavelength
        fft_index = fft.drop(fft[fft_period > max_period].index)
        
        if index is None:
            if threshold is None:
                self.index = fft_index['amplitude'].idxmax()
            else:
                A_normalized = fft_index['amplitude'] / max(fft_index['amplitude'])
                self.index = np.flatnonzero(A_normalized > threshold/100) + fft_index.index[0]
        else:
            self.index = index
        self.A = fft_index.amplitude[self.index]
        self.w = fft_index.wavelength[self.index]
        self.phi = fft_index.phase_shift[self.index]
        
        return self.index, self.A, self.w, self.phi
    
    def fit_model(self,
                   x = 400,
                   wave_piez = np.ones(40),
                   file_wave = None,
                   **kwargs,
                   ):
        
        self.wave_piez = wave_piez
        
        if np.isscalar(self.index):
            n_fft = 1
        else:
            n_fft = len(self.index)
        
        def model(t, x, A, w, phi, nt, n_fft, S_K):           
            A =     np.tile(A,  (nt,1))
            w =     np.tile(w,  (nt,1))
            phi =   np.tile(phi,(nt,1))
            t =     np.tile(t,  (n_fft,1)).T
            
            h_xt = np.sum( A * np.exp(-x * np.sqrt(w * S_K/2 )) * np.cos(w*t + phi - x * np.sqrt(w * S_K/2 )), axis = 1 )
            
            return (h_xt)
    
        params = lmfit.Parameters()
        params.add('S_K',               value = 2E-7, min= 1E-9, max= 1E-1)
        
        m = lmfit.Model(model, independent_vars = ['t','x','A','w','phi','nt','n_fft'])
        result = m.fit(self.wave_piez, 
                       params, 
                       t = self.t_piez, 
                       x = self.x_piez, 
                       A = self.A, 
                       w = self.w, 
                       phi = self.phi, 
                       nt = len(self.t_piez),
                       n_fft = n_fft,
                       method = 'leastsqrt')
        
        self.result_init_fit = result.init_fit
        self.result_best_fit = result.best_fit
        
        self.sk_fit     = result.best_values['S_K']
        sk_numeric = self.ss / self.hk
        self.Rel_err = round(abs(self.sk_fit - sk_numeric)/sk_numeric * 100,1)
        
        return self.sk_fit, self.Rel_err, self.wave_piez, self.result_init_fit, self.result_best_fit
    
    def check_fit_model(self,
                         **kwargs,
                         ):
        #################################################################################
        ### Check availability of wave decomposition components of input wave       
        #################################################################################
        if self.fft is None: 
            self.decompose_wave_fft(**kwargs)
        
        #################################################################################
        ### Set up analytical solution
        #################################################################################      
        A = np.array([ self.fft['amplitude'] ])
        w = np.array([ self.fft['wavelength'] ])
        phi = np.array([ self.fft['phase_shift'] ])
        
        x = self.x_piez
        t = np.array([self.t_piez]).transpose()
        
        h_t = (A * np.exp( -x*np.sqrt(w * self.sk_fit/2) ) * np.cos( w*t + phi -x*np.sqrt(w * self.sk_fit/2) ) ).sum(axis=1)
                
        self.piez_fit = h_t

        return self.piez_fit
        
    def write_ana_to_pickle(self,
                        file_results = None,                            
                        **kwargs,
                        ):

        if file_results is None:
             file_results= r'{}/{}_analytical.p'.format(self.task_root,self.task_name)

        # Write data in binary format
        with open(file_results, 'wb') as filehandle:
            # store the data as binary data stream
            pickle.dump([self.times_ana,self.x_ana,self.head_tx_ana], filehandle)
        print("\nAnalytical results saved to binary (pickle) file: \n {}".format(file_results))

    def read_ana_from_pickle(self,
                             file_results = None,                            
                             **kwargs,
                             ):
        
        if file_results is None:
            file_results= r'{}/{}_analytical.p'.format(self.task_root,self.task_name)

        if not os.path.isfile(file_results):
            raise ValueError('File with stored analytical model results not existant at: \n {}'.format(file_results))

        # read the data as binary data stream
        with open(file_results, 'rb') as filehandle:
            data = pickle.load(filehandle)
        self.x_ana = data[0]
        self.times_ana = data[1]
        self.head_tx_ana = data[2].T
        
        return self.times_ana,self.x_ana,self.head_tx_ana

def find_nearest_value(value, array):

    """Find match of given 'value' in given 'array'.

        Parameter
        ---------
        
        value       :   float    
                        value to find in array
        array       :   array
                        search for nearest match in this numpy array
        
        Return
        ------
        match       :   float
                        value in 'array' being closest to 'value'
    """


    array=np.array(array)

    index = (np.abs(array-value)).argmin()
    return array[index]

def find_nearest_index_array(value, array):
    
    """Find index of nearest match of given 'value' in given 'array'.

        Parameter
        ---------
        
        value       :   float
                        index of this number will be found in array
        array       :   array
                        search for nearest match in this numpy array
        
        Return
        ------
        index       :   int
                        index of entry in 'array' being closest to 'value'
    """
    
    array=np.array(array)
    value=np.array(value)
    index = np.array(value)
    
    for i in range(len(value)):
        index[i] = (np.abs(array-value[i])).argmin()
    
    return index.astype(int)

def find_nearest_index(value, array):

    """Find index of nearest match of given 'value' in given 'array'.

        Parameter
        ---------
        
        value       :   float    
                        index of this number will be found in array
        array       :   array
                        search for nearest match in this numpy array
        
        Return
        ------
        index       :   int
                        index of entry in 'array' being closest to 'value'
    """
    
    array=np.array(array)
    index = (np.abs(array-value)).argmin()

    return index

colors = ["blue","red","orange","black","green"]
